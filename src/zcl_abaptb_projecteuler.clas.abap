CLASS zcl_abaptb_projecteuler DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    TYPES:
      BEGIN OF ty_gcd,
        divisor TYPE int8,
      END OF ty_gcd .
    TYPES:
      tt_gcd TYPE STANDARD TABLE OF ty_gcd WITH KEY divisor .

    CLASS-METHODS p001_multiples_of_3_or_5
      IMPORTING
        !max_loops    TYPE i DEFAULT '1000'
      RETURNING
        VALUE(result) TYPE i .
    CLASS-METHODS p002_even_fibonacci_numbers
      IMPORTING
        !below_certain_value TYPE i DEFAULT '4000000'
      RETURNING
        VALUE(result)        TYPE i .
    CLASS-METHODS p003_largest_prime_factor
      IMPORTING
        !number TYPE int8 DEFAULT '600851475143'
      EXPORTING
        !result TYPE int8
        !gcd    TYPE tt_gcd .
    CLASS-METHODS p004_largest_palindrome_prod
      CHANGING
        !counter1     TYPE int8 DEFAULT '999'
        !counter2     TYPE int8 DEFAULT '999'
      RETURNING
        VALUE(result) TYPE int8 .
    CLASS-METHODS p005_smallest_multiple
      IMPORTING
        !iteration    TYPE int8 DEFAULT '20'
      RETURNING
        VALUE(result) TYPE int8 .
    CLASS-METHODS p006_sum_square_difference
      IMPORTING
        !iteration    TYPE int8 DEFAULT '100'
      RETURNING
        VALUE(result) TYPE int8 .
    CLASS-METHODS p007_10001st_prime
      IMPORTING
        !xth_prime_number TYPE int8 DEFAULT '10001'
      RETURNING
        VALUE(result)     TYPE int8 .
protected section.
private section.

  data GV_PROBLEM_003_RESULT type INT8 .
  data GT_GCD type TT_GCD .

  methods P003_DIVISOR_GET
    returning
      value(RESULT) type TT_GCD .
  methods P003_RECURSIVE
    importing
      !NUMBER type INT8 .
  methods P003_RESULT_GET
    returning
      value(RESULT) type INT8 .
  methods P003_RESULT_SET
    importing
      !NUMBER type INT8 .
  class-methods P004_NUMBERS_LENGTH
    importing
      !NUMBER type INT8
    returning
      value(RESULT) type INT8 .
  class-methods P005_GCD
    importing
      !IV_A type INT8
      !IV_B type INT8
    returning
      value(RV_RESULT) type INT8 .
  class-methods P005_LCM
    importing
      !IV_A type INT8
      !IV_B type INT8
    returning
      value(RV_RESULT) type INT8 .
  class-methods P007_IS_PRIME_NUMBER
    importing
      !NUMBER type INT8
    returning
      value(RESULT) type ABAP_BOOL .
ENDCLASS.



CLASS ZCL_ABAPTB_PROJECTEULER IMPLEMENTATION.


  METHOD P001_MULTIPLES_OF_3_OR_5.
**********************************************************************
* ## Problem 1
*    If we list all the natural numbers below 10 that are multiples of 3
*    or 5 , we get 3, 5, 6 and 9. The sum of these multiples is 23.
*
*    Find the sum of all the multiples of 3 or 5 below 1000.
**********************************************************************

    CLEAR: result.

    CONSTANTS:
      divisor_3 TYPE i VALUE 3,
      divisor_5 TYPE i VALUE 5.

    DO max_loops - 1 TIMES.
      IF sy-index MOD divisor_3 = 0 OR
         sy-index MOD divisor_5 = 0.
        result = result + sy-index.
      ELSE.
        CONTINUE.
      ENDIF.
    ENDDO.

  ENDMETHOD.


  METHOD p002_even_fibonacci_numbers.
**********************************************************************
* ## Problem 2
*    Each new term in the Fibonacci sequence is generated by adding
*    the previous two terms. By starting with 1 and 2, the first 10
*    terms will be:
*
*    1,2,3,5,8,13,21,34,55,89,...
*
*    By considering the terms in the Fibonacci sequence whose
*    values do not exceed four million, find the sum of the
*    even-valued terms.
**********************************************************************

    CLEAR: result.

    DATA:
      a TYPE i VALUE 0,
      b TYPE i VALUE 1,
      z TYPE i.

    DO.
      z = a + b.
      a = b.
      b = z.

      IF z > below_certain_value.
        EXIT.
      ENDIF.

      IF z MOD 2 = 0.
        result = result + z.
      ENDIF.

    ENDDO.

  ENDMETHOD.


 METHOD P003_DIVISOR_GET.
    CLEAR: result.
    result = gt_gcd.
  ENDMETHOD.


  METHOD p003_largest_prime_factor.
**********************************************************************
* ## Problem 3
*    The prime factors of 13195 are 5, 7, 13 and 29.
*
*    What is the largest prime factor of the number 600851475143?
**********************************************************************

    CLEAR: result, gcd.

    " Note: 1 is not considered a prime number as prime numbers are defined for natural numbers greater than 1.
    IF number < 2.
      RETURN.
    ENDIF.

    DATA(lo_object) = NEW zcl_abaptb_projecteuler( ).

    lo_object->p003_recursive( number ).

    result = lo_object->p003_result_get( ).

    gcd = lo_object->p003_divisor_get( ).

  ENDMETHOD.


  METHOD p003_recursive.
**********************************************************************
* ## Problem 3
*    The prime factors of 13195 are 5, 7, 13 and 29.
*
*    What is the largest prime factor of the number 600851475143?
**********************************************************************
    DATA:
      divisor               LIKE number,
      smallest_prime_factor LIKE number.

    DATA(largest_number) = number.

    DO .
      IF sy-index < 2.
        CONTINUE.
      ENDIF.

      IF largest_number MOD sy-index = 0.
        divisor = sy-index.
        gt_gcd = VALUE #( BASE gt_gcd ( divisor = divisor ) ).
        smallest_prime_factor = largest_number / divisor.
        IF smallest_prime_factor = 1.
          p003_result_set( largest_number ).
        ELSE.
          p003_recursive( smallest_prime_factor ).
        ENDIF.
        RETURN.
      ENDIF.

    ENDDO.

  ENDMETHOD.


 METHOD P003_RESULT_GET.
    CLEAR: result.
    result = gv_problem_003_result.
  ENDMETHOD.


  METHOD P003_RESULT_SET.
    gv_problem_003_result = number.
  ENDMETHOD.


  METHOD p004_largest_palindrome_prod.
**********************************************************************
* ## Problem 4
*    A palindromic number reads the same both ways.
*    The largest palindrome made from the product of two 2-digit
*    numbers is 9009 = 91 * 99
*
*    Find the largest palindrome made from the product
*    of two 3-digit numbers.
**********************************************************************

    CLEAR: result.

    DATA:
      lv_max_palindrome   TYPE int8 VALUE 0,
      lv_wert1_palindrome TYPE int8,
      lv_wert2_palindrome TYPE int8,
      lv_product          TYPE int8,
      lv_number1          TYPE int8,
      lv_number2          TYPE int8.

    DO counter1 TIMES.
      lv_number1 = sy-index.
      IF p004_numbers_length( lv_number1 ) < p004_numbers_length( counter1 ).
        CONTINUE.
      ENDIF.

      DO counter2 TIMES.
        lv_number2 = sy-index.
        IF p004_numbers_length( lv_number2 ) < p004_numbers_length( counter2 ).
          CONTINUE.
        ENDIF.

        lv_product = lv_number1 * lv_number2.

        IF lv_product = CONV int8( reverse( CONV string( lv_product ) ) ).
          IF lv_product > lv_max_palindrome.
            lv_max_palindrome = lv_product.
            lv_wert1_palindrome = lv_number1.
            lv_wert2_palindrome = lv_number2.
          ENDIF.
        ENDIF.
      ENDDO.
    ENDDO.

    counter1 = lv_wert1_palindrome.
    counter2 = lv_wert2_palindrome.
    result = lv_max_palindrome.

  ENDMETHOD.


  METHOD p004_numbers_length.

    CLEAR: result.

    result = strlen( CONV string( number ) ).

  ENDMETHOD.


  METHOD p005_gcd.
    " Function to calculate the greatest common divisor (GCD)
    CLEAR: rv_result.

    DATA:
      lv_temp TYPE i.

    DATA(lv_a) = iv_a.
    DATA(lv_b) = iv_b.

    lv_temp = lv_a MOD lv_b.

    WHILE lv_temp NE 0.
      lv_a = lv_b.
      lv_b = lv_temp.
      lv_temp = lv_a MOD lv_b.
    ENDWHILE.
    rv_result = lv_b.
  ENDMETHOD.


  METHOD P005_LCM.
    " Function to calculate the least common multiple (LCM)
    CLEAR: rv_result.
    DATA: lv_gcd TYPE i.
    lv_gcd = p005_gcd( iv_a = iv_a
                       iv_b = iv_b ).
    rv_result = iv_a * iv_b / lv_gcd.
  ENDMETHOD.


  METHOD p005_smallest_multiple.
**********************************************************************
* ## Problem 5
*    2520 is the smallest number that can be divided by each of the
*    numbers from 1 to 10 without any remainder.
*
*    What is the smallest positive number that is evenly divisible
*    by all of the numbers from 1 to 20?
**********************************************************************

    CLEAR: result.

    DATA: lv_result  TYPE int8 VALUE 1,
          lv_divisor TYPE int8.

    " Loop through divisors from 2 to X
    DO iteration TIMES.
      lv_divisor = sy-index.
      IF lv_divisor < 2.
        CONTINUE.
      ENDIF.

      " Calculate the least common multiple with the current divisor
      lv_result = p005_lcm( iv_a = lv_result
                            iv_b = lv_divisor ).

    ENDDO.

    " Output the smallest positive number
    result = lv_result.

  ENDMETHOD.


  METHOD p006_sum_square_difference.
**********************************************************************
* ## Problem 6
*    The sum of the squares of the first ten natural numbers is,
*    1² + 2² + ... + 10² = 385.
*
*    The square of the sum of the first ten natural numbers is,
*    (1 + 2 + ... + 10)² = 55² = 3025.
*
*    Hence the difference between the sum of the squares of the
*    first ten natural numbers and the square of the sum is
*    3025 - 385 = 2640.
*
*    Find the difference between the sum of the squares of the first
*    one hundred natural numbers and the square of the sum.
**********************************************************************

    CLEAR: result.

    DATA:
      current_iteration TYPE int8,
      sum_squares       TYPE int8,
      square_sum        TYPE int8.

    DO iteration TIMES.
      current_iteration = sy-index.
      sum_squares += ipow( base = current_iteration exp = 2 ).
      square_sum += current_iteration.
    ENDDO.

    square_sum = ipow( base = square_sum exp = 2 ).

    " Alternatively, for faster processing, consider using the following mathematical formulas:
*    sum_squares = ( 2 * iteration + 1 ) * ( iteration + 1 ) * iteration / 6.
*    square_sum = ipow( base = ( iteration * ( iteration + 1 ) / 2 ) exp = 2 ).

    result = square_sum - sum_squares.

  ENDMETHOD.


  METHOD p007_10001st_prime.
**********************************************************************
* ## Problem 7
*    By listing the first six prime numbers: 2, 3, 5, 7, 11 and 13
*    we can see that the 6th prime is 13.
*
*    What is the 10001st prime number?
**********************************************************************

    CLEAR: result.

    DATA:
      current_number        TYPE int8,
      quantity_prime_number TYPE int8.

    DO .
      current_number = sy-index.

      IF abap_true = p007_is_prime_number( current_number ).
        quantity_prime_number += 1.
      ELSE.
        CONTINUE.
      ENDIF.

      IF quantity_prime_number = xth_prime_number.
        result = current_number.
        RETURN.
      ENDIF.

    ENDDO.

  ENDMETHOD.


  METHOD p007_is_prime_number.
    CLEAR: result.

    DATA: number_prime_numbers LIKE number.

    IF number = 1.
      result = abap_false.
      RETURN.

    ELSEIF number = 2.
      result = abap_true.
      RETURN.

    ELSEIF number = 3.
      result = abap_true.
      RETURN.

    ELSEIF number MOD 2 = 0.
      result = abap_false.
      RETURN.

    ELSEIF number MOD 3 = 0.
      result = abap_false.
      RETURN.

    ELSE.
      DO number TIMES.
        IF sy-index < 2.
          CONTINUE.
        ELSEIF number MOD sy-index = 0.
          number_prime_numbers += 1.

          IF number_prime_numbers > 1.
            result = abap_false.
            RETURN.
          ENDIF.
        ENDIF.
      ENDDO.

      IF number_prime_numbers = 1.
        result = abap_true.
      ELSE.
        result = abap_false.
      ENDIF.

    ENDIF.

  ENDMETHOD.
ENDCLASS.
